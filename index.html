<!DOCTYPE html>
<html lang="az">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <title>Plinko — Real Fizika (Səsli)</title>
    <style>
      :root {
        --bg: #0d47a1;
        --panel: #0b3b85;
        --text: #fff;
        --accent: #ffd600;
        --peg: #e3f2fd;
        --win: #00e676;
        --lose: #ff5252;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: var(--bg);
        color: var(--text);
        font-family: sans-serif;
      }
      header,
      footer {
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      .stat {
        background: rgba(0, 0, 0, 0.2);
        padding: 8px 12px;
        border-radius: 12px;
        text-align: center;
      }
      .bets {
        display: flex;
        gap: 6px;
      }
      .chip {
        background: #ffca28;
        border: none;
        border-radius: 999px;
        padding: 6px 10px;
        font-weight: 700;
      }
      .chip.active {
        outline: 2px solid #fff;
      }
      main {
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      #board {
        flex: 1;
        width: 100%;
        height: 100%;
      }
      .legend {
        display: flex;
        gap: 4px;
        padding: 6px;
      }
      .slot {
        flex: 1;
        text-align: center;
        font-size: 12px;
        padding: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
      }
      #play,
      #cashout,
      #addMoney {
        padding: 12px;
        font-weight: 700;
        border: none;
        border-radius: 12px;
      }
      #play {
        flex: 1;
        background: linear-gradient(180deg, #1e88e5, #1565c0);
        color: #fff;
      }
      #cashout {
        background: #ffca28;
        color: #000;
      }
      #addMoney {
        background: #00e676;
        color: #fff;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="stat"><b>Balans</b><span id="bal">0.00 AZN</span></div>
      <div>
        <div class="bets" id="bets"></div>
        <div style="text-align: center; font-size: 12px">
          Mərc: <span id="betLbl">0.20</span> AZN
        </div>
      </div>
      <div class="stat"><b>Uduş</b><span id="lastWin">0.00 AZN</span></div>
    </header>
    <main>
      <canvas id="board"></canvas>
      <div class="legend" id="legend"></div>
    </main>
    <footer>
      <button id="play">OYNA</button>
      <button id="cashout">PUL ÇIXART</button>
      <button id="addMoney">+ PUL</button>
    </footer>

    <script>
      // ==== Parametrlər ====
      const START_BALANCE = 10.0;
      const BET_OPTIONS = [0.2, 0.5, 1.0, 2];
      const MULTIPLIERS = [5, 3, 0.3, 0.2, 0.2, 0.3, 3, 5];
      const PEG_ROWS = 7,
        GRAVITY = 0.35,
        RESTITUTION = 0.65,
        AIR_DRAG = 0.999,
        MAX_VX = 4.2,
        SUBSTEPS = 2;

      const canvas = document.getElementById("board"),
        ctx = canvas.getContext("2d");
      const balEl = document.getElementById("bal"),
        lastWinEl = document.getElementById("lastWin");
      const legendEl = document.getElementById("legend"),
        playBtn = document.getElementById("play");
      const betLbl = document.getElementById("betLbl"),
        betsWrap = document.getElementById("bets");
      const addBtn = document.getElementById("addMoney");

      let DPR = 1,
        W = 0,
        H = 0;
      let balance =
        parseFloat(localStorage.getItem("plinko_balance")) || START_BALANCE;
      let bet = BET_OPTIONS[0],
        ball = null,
        pegs = [],
        walls = [],
        slotLineY = 0;

      // ==== Səs ====
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      function playSound() {
        const osc = audioCtx.createOscillator(),
          gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.value = 700 + Math.random() * 250;
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + 0.15
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
      }

      function saveBalance() {
        localStorage.setItem("plinko_balance", balance.toFixed(2));
      }
      function formatAZN(v) {
        return v.toFixed(2) + " AZN";
      }
      function setBet(v) {
        bet = v;
        betLbl.textContent = bet.toFixed(2);
        Array.from(betsWrap.children).forEach((btn) => {
          btn.classList.toggle("active", +btn.dataset.v === bet);
        });
        updateButtons();
      }
      function updateHUD(win = 0) {
        balEl.textContent = formatAZN(balance);
        lastWinEl.textContent = formatAZN(win);
        updateButtons();
        saveBalance();
      }
      function updateButtons() {
        playBtn.disabled = balance < bet;
      }

      BET_OPTIONS.forEach((v) => {
        const b = document.createElement("button");
        b.className = "chip";
        b.textContent = v.toFixed(2);
        b.dataset.v = v;
        b.onclick = () => setBet(v);
        betsWrap.appendChild(b);
      });

      function sizeCanvas() {
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = canvas.getBoundingClientRect();
        W = Math.floor(rect.width);
        H = Math.floor(rect.height);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        buildBoard();
      }
      function buildBoard() {
        pegs = [];
        const marginX = 26,
          topY = 40,
          bottomMargin = 70;
        const usableW = W - marginX * 2;
        const rowGap = (H - topY - bottomMargin) / PEG_ROWS;
        const colsTop = 1,
          pegR = 4.5;
        for (let r = 0; r < PEG_ROWS; r++) {
          const cols = colsTop + r,
            gap = usableW / (cols - 1),
            y = topY + r * rowGap;
          for (let c = 0; c < cols; c++) {
            const x = marginX + c * gap;
            pegs.push({ x, y, r: pegR });
          }
        }
        walls = [
          { x: marginX - 6, y1: topY - 10, y2: H - 60 },
          { x: W - (marginX - 6), y1: topY - 10, y2: H - 60 },
        ];
        slotLineY = H - 60;
        drawStatic();
      }
      function drawStatic() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle =
          getComputedStyle(document.documentElement).getPropertyValue(
            "--peg"
          ) || "#e3f2fd";
        pegs.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.lineWidth = 2;
        walls.forEach((w) => {
          ctx.beginPath();
          ctx.moveTo(w.x, w.y1);
          ctx.lineTo(w.x, w.y2);
          ctx.stroke();
        });
        const n = MULTIPLIERS.length,
          slotW = W / n;
        ctx.beginPath();
        ctx.moveTo(0, slotLineY);
        ctx.lineTo(W, slotLineY);
        ctx.stroke();
        for (let i = 0; i <= n; i++) {
          ctx.beginPath();
          ctx.moveTo(i * slotW, slotLineY);
          ctx.lineTo(i * slotW, H);
          ctx.stroke();
        }
        legendEl.innerHTML = "";
        MULTIPLIERS.forEach((m) => {
          const d = document.createElement("div");
          d.className = "slot";
          d.textContent = m.toFixed(2) + "×";
          d.style.color =
            m > 1 ? "var(--win)" : m === 0 ? "var(--lose)" : "#fff";
          legendEl.appendChild(d);
        });
      }
      function reflectVelocity(vx, vy, nx, ny) {
        const dot = vx * nx + vy * ny;
        vx = vx - (1 + RESTITUTION) * dot * nx;
        vy = vy - (1 + RESTITUTION) * dot * ny;
        return [vx, vy];
      }
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function dropBall() {
        ball = {
          x: W / 2,
          y: 18,
          vx: 0,
          vy: 0,
          r: 7.5,
          settled: false,
          hitFloor: false,
        };
        updateButtons();
      }
      function settleAndPay() {
        const n = MULTIPLIERS.length,
          slotW = W / n;
        let idx = Math.floor(clamp(ball.x, 0, W - 1) / slotW);
        idx = clamp(idx, 0, n - 1);
        const mult = MULTIPLIERS[idx],
          win = +(bet * mult).toFixed(2);
        balance = +(balance + win).toFixed(2);
        updateHUD(win);
        ball = null;
      }
      function step(dt) {
        if (!ball) return;
        for (let s = 0; s < SUBSTEPS; s++) {
          ball.vy += GRAVITY * (dt / SUBSTEPS);
          ball.x += ball.vx;
          ball.y += ball.vy;
          walls.forEach((w) => {
            if (ball.y > w.y1 && ball.y < w.y2) {
              const side = w.x < W / 2 ? 1 : -1;
              if (Math.abs(ball.x - w.x) < ball.r) {
                const nx = side,
                  ny = 0;
                ball.x = w.x + side * ball.r;
                [ball.vx, ball.vy] = reflectVelocity(ball.vx, ball.vy, nx, ny);
                playSound();
              }
            }
          });
          for (let p of pegs) {
            const dx = ball.x - p.x,
              dy = ball.y - p.y,
              dist = Math.hypot(dx, dy),
              minD = ball.r + p.r;
            if (dist < minD) {
              let nx = dx / (dist || 1e-6),
                ny = dy / (dist || 1e-6);
              const overlap = minD - dist;
              ball.x += nx * overlap;
              ball.y += ny * overlap;
              [ball.vx, ball.vy] = reflectVelocity(ball.vx, ball.vy, nx, ny);
              ball.vx += (Math.random() - 0.5) * 0.6;
              playSound();
            }
          }
          if (ball.y + ball.r > slotLineY) {
            ball.y = slotLineY - ball.r;
            ball.vy = -ball.vy * RESTITUTION * 0.35;
            ball.vx *= 0.98;
            if (!ball.hitFloor) {
              playSound();
              ball.hitFloor = true;
            }
            if (Math.hypot(ball.vx, ball.vy) < 0.35) {
              ball.settled = true;
            }
          }
          ball.vx = clamp(ball.vx * AIR_DRAG, -MAX_VX, MAX_VX);
          ball.vy = ball.vy * AIR_DRAG;
        }
        if (ball && ball.settled) {
          settleAndPay();
        }
      }
      function draw() {
        drawStatic();
        if (ball) {
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
          ctx.fillStyle =
            getComputedStyle(document.documentElement).getPropertyValue(
              "--accent"
            ) || "#ffd600";
          ctx.shadowColor = "rgba(0,0,0,.35)";
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      let last = 0;
      function loop(ts) {
        const dt = Math.min(32, ts - last || 16);
        last = ts;
        step(dt / 16.6667);
        draw();
        requestAnimationFrame(loop);
      }

      // ==== Fullscreen API ====
      function goFullscreen() {
        const el = document.documentElement;
        if (el.requestFullscreen) {
          el.requestFullscreen();
        } else if (el.webkitRequestFullscreen) {
          el.webkitRequestFullscreen();
        }
      }

      playBtn.addEventListener("click", () => {
        goFullscreen();
        if (balance < bet) return;
        balance = +(balance - bet).toFixed(2);
        updateHUD(0);
        dropBall();
      });
      addBtn.addEventListener("click", () => {
        balance = +(balance + 0).toFixed(2);
        updateHUD(0);
      });
      document.getElementById("cashout").addEventListener("click", () => {
        window.location.href = "cashout.html";
      });

      window.addEventListener("resize", sizeCanvas);
      sizeCanvas();
      setBet(bet);
      updateHUD(0);
      requestAnimationFrame(loop);
    </script>
    <!--Start of Tawk.to Script-->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/68ad6b379dfb481927183a8f/1j3imlkns';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!--End of Tawk.to Script-->
  </body>
</html>

